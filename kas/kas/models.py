import base64
import calendar
import csv
import math
import random
import re
import string
import uuid
from functools import cached_property
from io import StringIO
from time import sleep
from uuid import uuid4

from django.conf import settings
from django.contrib.auth import get_user_model
from django.contrib.contenttypes.models import ContentType
from django.core.exceptions import ValidationError
from django.core.files import File
from django.core.validators import MinValueValidator, RegexValidator
from django.db import models
from django.db.models import UniqueConstraint, Q, Sum, Max
from django.db.models.signals import post_save, post_delete
from django.db.transaction import atomic
from django.dispatch import receiver
from django.forms import model_to_dict
from django.utils import timezone
from django.utils.translation import gettext as _
from eskat.models import ImportedR75PrivatePension
from kas.eboks import EboksClient, EboksDispatchGenerator
from kas.managers import PolicyTaxYearManager
from prisme.models import Prisme10QBatch, Transaction
from requests.exceptions import RequestException
from simple_history.models import HistoricalRecords


def filefield_path(instance, filename):
    return filename


def get_admin_user():
    # User to attach to notes that are generated by the system
    return get_user_model().objects.get(username="admin")


class HistoryMixin(object):
    UNCHANGED = 0
    UPDATED = 1
    CREATED = 2

    """
    :param data: dict to populate model instance
    :param keys: keys in dict that define how to look for an existing instance. KvPs in data are extracted by keys for the lookup
    Updates an existing instance, or creates a new one if one doesn't exist.
    """

    @classmethod
    def update_or_create(cls, data, *keys):
        status = HistoryMixin.UNCHANGED
        try:
            item = cls.objects.get(**{k: v for k, v in data.items() if k in keys})
            existing_dict = {k: v for k, v in model_to_dict(item).items() if k in data}
            if "id" in existing_dict:
                del existing_dict["id"]
            new_dict = {
                k: v.pk if isinstance(v, models.Model) else v for k, v in data.items()
            }
            if existing_dict != new_dict:
                for k, v in data.items():
                    setattr(item, k, v)
                item._change_reason = "Updated by import"
                item.save()
                status = HistoryMixin.UPDATED
        except cls.DoesNotExist:
            item = cls(**data)
            item.change_reason = "Created by import"
            item.save()
            status = HistoryMixin.CREATED
        return item, status


def pension_company_agreement_file_path(instance, filename):
    return "agreements/{id}/{filename}".format(id=instance.id, filename=filename)


class PensionCompany(models.Model):
    class Meta:
        ordering = ["name"]
        verbose_name = _("pensionsselskab")
        verbose_name_plural = _("pensionsselskaber")

    name = models.TextField(
        db_index=True,
        verbose_name=_("Navn"),
        help_text=_("Pensionselskabets navn"),
        max_length=255,
        blank=True,
        null=True,
    )

    address = models.TextField(
        verbose_name=_("Adresse"),
        blank=True,
        null=True,
    )

    email = models.TextField(
        verbose_name=_("Email"), help_text=_("Email"), blank=True, null=True
    )

    phone = models.TextField(
        verbose_name=_("Telefon"), help_text=_("Telefon"), blank=True, null=True
    )

    res = models.IntegerField(
        verbose_name=_("Registrerings nr."),
        help_text=_(
            "Identificerende nummer (reg.nr. for banker, se-nr for pensionsselskaber)"
        ),
        unique=True,
        null=True,  # This will be null when created as a self-reported company
        validators=(MinValueValidator(limit_value=1),),
    )

    agreement_present = models.BooleanField(
        default=False, verbose_name=_("Foreligger der en aftale med skattestyrelsen")
    )

    agreement = models.FileField(
        upload_to=pension_company_agreement_file_path, default="", blank=True
    )

    def __str__(self):
        return f"{self.name} ({self.res})"


tax_year_part_year_choices = (
    ("selvangivelse", _("Selvangivelsesperiode")),
    ("ligning", _("Ligningsperiode")),
    ("genoptagelsesperiode", _("Genoptagelsesperiode")),
)


def max_sixty_characters_per_line_validator(value):
    MAX_CHARACTERS_PER_LINE = 60
    for x in value.splitlines():
        if len(x) > MAX_CHARACTERS_PER_LINE:
            raise ValidationError(
                _("Ratetekst må ikke indeholde linjer med mere end 60 tegn")
            )


class TaxYear(models.Model):
    class Meta:
        ordering = ["-year"]

    year = models.IntegerField(
        db_index=True,  # This should most likely be removed unless there is a point in having 2 exact same indices?
        verbose_name=_("Skatteår"),
        help_text=_("Skatteår"),
        unique=True,
        null=False,
        blank=False,
        validators=(MinValueValidator(limit_value=2000),),
    )
    year_part = models.TextField(
        choices=tax_year_part_year_choices,
        default="selvangivelse",
        verbose_name=_("Periode"),
    )

    rate_text_for_transactions = models.TextField(
        verbose_name=_("Tekst brugt i opkrævninger sendt ud for skatteåret"),
        default="",
        validators=[max_sixty_characters_per_line_validator],
    )

    @property
    def is_leap_year(self):
        return calendar.isleap(self.year)

    @property
    def days_in_year(self):
        return 366 if self.is_leap_year else 365

    @cached_property
    def get_current_lock(self):
        """
        There should always be at least one "active" lock for each year.
        So this should never raise an IndexError if it does this would be a serious problem and should result in a 500.
        """
        return self.locks.filter(interval_to__isnull=True).order_by("-interval_from")[0]

    def __str__(self):
        return str(self.year)


# If a person has the status undefined, it means that we have not tryed finding a status in Dafo, und we do not show a statustekst in UI
# If a person has the status Alive, it is a standard status that we do nat want to show in the UI
recipient_recieve_statuses = (
    ("Undefined", ""),
    ("Invalid", _("Ugyldig")),
    ("Alive", ""),
    ("Dead", _("Afdød")),
)


class Lock(models.Model):
    class Meta:
        ordering = ("interval_from",)

    interval_from = models.DateField()

    interval_to = models.DateField(null=True, blank=True)

    taxyear = models.ForeignKey(
        TaxYear, db_index=True, on_delete=models.PROTECT, related_name="locks"
    )

    @cached_property
    def total_tax_sum(self):
        return sum([settlement.total_tax for settlement in self.settlements.all()])

    @cached_property
    def previous_transactions_sum(self):
        return sum(
            [
                settlement.previous_transactions_sum
                for settlement in self.settlements.all()
            ]
        )

    @property
    def remainder_sum(self):
        sum = 0
        for stl in self.settlements.all():
            sum += stl.get_calculation_amounts().get("remainder")

        return sum

    @property
    def remaining_transaction_sum(self):
        return self.total_tax_sum - self.previous_transactions_sum

    @property
    def allow_closing(self):
        """
        All transactions should have been transfered to prisme before we can close the lock
        And you cannot close a lock that is all ready closed.
        """
        if not self.interval_to and self.remaining_transaction_sum == 0:
            return True
        return False

    def __str__(self):
        if self.interval_to:
            return _("%(year)s (Låst)" % {"year": self.taxyear.year})
        else:
            return _("%(year)s (Åben)" % {"year": self.taxyear.year})


@receiver(post_save, sender=TaxYear, dispatch_uid="create_lock_for_year")
def create_lock_for_year(sender, instance, created, **kwargs):
    """
    Always create a new open lock when a taxyear is created.
    """
    if created:
        Lock.objects.create(taxyear=instance, interval_from=timezone.now().date())


class Person(HistoryMixin, models.Model):
    class Meta:
        ordering = ["cpr"]

    history = HistoricalRecords()

    cpr = models.TextField(
        db_index=True,
        verbose_name=_("CPR nummer"),
        help_text=_("CPR nummer"),
        unique=True,
        null=False,
        max_length=10,
        validators=(RegexValidator(regex=r"\d{10}"),),
    )

    name = models.TextField(blank=True, null=True)
    municipality_code = models.IntegerField(blank=True, null=True)
    municipality_name = models.TextField(blank=True, null=True)
    address_line_1 = models.TextField(blank=True, null=True)
    address_line_2 = models.TextField(blank=True, null=True)
    address_line_3 = models.TextField(blank=True, null=True)
    address_line_4 = models.TextField(blank=True, null=True)
    address_line_5 = models.TextField(blank=True, null=True)
    full_address = models.TextField(blank=True, null=True)
    updated_from_dafo = models.BooleanField(
        verbose_name="Opdateret fra datafordeleren", default=False
    )
    status = models.TextField(choices=recipient_recieve_statuses, default="Undefined")

    # testpersons should not be included in prisme data
    is_test_person = models.BooleanField(default=False)

    @property
    def postal_address(self):
        return "\n".join(
            [
                x
                for x in (
                    self.address_line_1,
                    self.address_line_2,
                    self.address_line_3,
                    self.address_line_4,
                    self.address_line_5,
                )
                if x
            ]
        )

    @property
    def cpr_formatted(self):
        return f"{self.cpr[0:6]}-{self.cpr[6:10]}"

    def __str__(self):
        return (
            f"{self.__class__.__name__}(cpr={self.cpr},municipality_code={self.municipality_code},"
            f"municipality_name={self.municipality_name},"
            f"address_line_1={self.address_line_1},address_line_2={self.address_line_2},"
            f"address_line_3={self.address_line_1},address_line_4={self.address_line_2},"
            f"address_line_5={self.address_line_2},"
            f"full_address={self.full_address})"
        )


eboks_dispatch_statuses = (
    ("created", _("Genereret")),
    (
        "send",
        _("Afsendt"),
    ),  # sent means that the message was successfully delivered to e-boks.
    (
        "post_processing",
        _("Afventer efterbehandling"),
    ),  # Sucessfully sent to proxy but awaiting post-processing next status is send
    ("failed", _("Afsendelse fejlet")),  # Could not deliver message.
)
# final state is either sent or failed

post_procssing_statuses = (
    ("pending", _("Afventer processering")),
    ("address resolved", _("Fundet gyldig postadresse")),
    ("address not found", _("Ingen gyldig postadresse")),
    ("remote printed", _("Overført til fjernprint")),
)

recipient_statuses = (
    ("", _("Gyldig E-boks modtager")),
    ("exempt", _("Fritaget modtager")),
    ("invalid", _("Ugyldig E-boks modtager (sendes til efterbehandling)")),
    ("dead", _("Afdød")),
    ("minor", _("Mindreårig")),
)


def taxslip_path_by_year(instance, filename):
    return f"taxslip/{instance.persontaxyear.year}/{uuid.uuid4()}.pdf"


class EboksDispatch(models.Model):
    title = models.TextField()
    status = models.TextField(
        choices=eboks_dispatch_statuses, default="created", blank=True
    )
    post_processing_status = models.TextField(
        choices=post_procssing_statuses, default="", blank=True
    )
    recipient_status = models.TextField(
        choices=recipient_statuses, default="", blank=True
    )
    message_id = models.TextField(blank=True, default="")  # eboks message_id
    created_at = models.DateTimeField(
        auto_now_add=True
    )  # When the settlement was created
    send_at = models.DateTimeField(
        null=True, blank=True
    )  # When the settlement was sendt

    @property
    def delivery_status(self):
        if self.status == "created":
            return _("Afventer afsendelse")
        elif self.status == "send":
            if self.recipient_status == "":
                return _("E-boks")
            elif self.recipient_status == "dead":
                return _("Ikke afsendt (afdød)")
            else:
                # exempt, minor, invalid
                if self.post_processing_status in (
                    "address resolved",
                    "remote printed",
                ):
                    return _("Fjernprint")
                elif self.post_processing_status == "address not found":
                    return _("Ingen gyldig postadresse")
        elif self.status == "post_processing":
            return _("Afventer efterbehandling")
        elif self.status == "failed":
            return _("Afsendelse fejlet")

    def get_final_status(self, client: EboksClient):
        if self.status != "post_processing":
            raise RuntimeError(
                "Cannot get updates for status {status} (needs status post_processing)".format(
                    status=self.status
                )
            )
        while self.status == "post_processing":
            resp = client.get_recipient_status([self.message_id])
            for message in resp.json():
                if self.message_id == message["message_id"]:
                    recipient = message["recipients"][0]
                    if recipient["post_processing_status"] != "pending":
                        self.status = "send"
                        self.post_processing_status = recipient[
                            "post_processing_status"
                        ]
                        self.save(update_fields=["status", "post_processing_status"])

            if self.status == "post_processing":
                # wait 10 seconds before getting another update
                sleep(10)

    @property
    def allow_dispatch(self):
        # a message is allowed to be dispatch if the status is either created or failed (re-trying)
        if self.status in ("created", "failed"):
            return True
        return False

    class Meta:
        abstract = True
        ordering = ("-created_at",)

    def dispatch_to_eboks(
        self,
        client: EboksClient,
        generator: EboksDispatchGenerator,
        file: File,
        cpr: str,
    ):
        if self.status == "send":
            raise RuntimeError(
                f"This {self.__class__.__name__} has already been dispatched!"
            )
        file.open(mode="rb")
        try:
            resp = client.send_message(
                message=generator.generate_dispatch(
                    title=self.title, number=cpr, pdf_data=base64.b64encode(file.read())
                ),
                message_id=client.get_message_id(),
            )
            jsonresponse = resp.json()
        except RequestException:
            self.status = "failed"
            self.save(update_fields=["status"])
            raise
        else:
            self.message_id = jsonresponse[
                "message_id"
            ]  # message_id might have changed so get it from the response
            # we always only have 1 recipient
            recipient = jsonresponse["recipients"][0]
            self.recipient_status = recipient["status"]
            self.send_at = timezone.now()
            if recipient["post_processing_status"] == "":
                self.status = "send"
            else:
                self.status = "post_processing"
            self.save(
                update_fields=["status", "message_id", "recipient_status", "send_at"]
            )
        finally:
            file.close()
        return self


class TaxSlipGenerated(EboksDispatch):
    file = models.FileField(upload_to=taxslip_path_by_year, null=True)


def delete_file(sender, instance, using, **kwargs):
    """
    This method expect a model with a filefield named file.
    """
    if instance.file:
        # delete the pdf file
        instance.file.delete(save=False)


post_delete.connect(
    delete_file, sender=TaxSlipGenerated, dispatch_uid="delete_tax_slip_file"
)


class PersonTaxYear(HistoryMixin, models.Model):
    all_documents_and_notes_handled = models.BooleanField(default=True)

    tax_slip = models.OneToOneField(
        TaxSlipGenerated, on_delete=models.PROTECT, blank=True, null=True
    )

    tax_year = models.ForeignKey(
        TaxYear,
        on_delete=models.PROTECT,
        null=False,
        blank=False,
    )

    person = models.ForeignKey(Person, on_delete=models.PROTECT, null=False)

    number_of_days = models.IntegerField(verbose_name="Antal dage", null=True)

    fully_tax_liable = models.BooleanField(
        verbose_name="Fuldt skattepligtig", default=True
    )

    foreign_pension_notes = models.TextField(
        verbose_name="Noter om pension i udlandet", null=True
    )

    general_notes = models.TextField(verbose_name="Yderligere noter", null=True)

    # Charfield instead of User, so if a user is deleted we still remember him
    updated_by = models.CharField(max_length=150, null=True)

    # Whether r75 data is corrected by the pension company or user
    corrected_r75_data = models.BooleanField(default=False)

    # Whether r75 data for this tax year comes from the 'future'.
    # i.e. it was submitted after the tax year was closed.
    future_r75_data = models.BooleanField(default=False)

    @property
    def year(self):
        return self.tax_year.year

    @classmethod
    def get_pdf_recipients_for_year_qs(
        cls, tax_year_obj_or_pk, exclude_already_generated=False
    ):
        qs = cls.objects.filter(
            fully_tax_liable=True,
            number_of_days__isnull=False,
            number_of_days__gt=0,
            tax_year=tax_year_obj_or_pk,
        )

        if exclude_already_generated:
            qs = qs.filter(tax_slip=None)

        return qs

    @property
    def days_in_year_factor(self):
        if self.number_of_days is None:
            return 1
        return self.number_of_days / self.tax_year.days_in_year

    def recalculate_mandtal(
        self, negative_payout_history_note=_("Genberegning af mandtal")
    ):
        number_of_days = 0
        fully_tax_liable = False
        qs = self.persontaxyearcensus_set.filter(fully_tax_liable=True)
        for person_tax_year_census in qs:
            number_of_days += person_tax_year_census.number_of_days
            fully_tax_liable = True
        number_of_days = min(number_of_days, self.tax_year.days_in_year)

        # Hvis number_of_days eller fully_tax_liable er ændret pga. genberegningen,
        # foretag genberegning på associerede policytaxyears
        if (
            number_of_days != self.number_of_days
            or fully_tax_liable != self.fully_tax_liable
        ):
            self.number_of_days = number_of_days
            self.fully_tax_liable = fully_tax_liable
            self.save()
            for policytaxyear in self.active_policies_qs:
                old_result = policytaxyear.calculated_result
                policytaxyear.recalculate(
                    negative_payout_history_note=negative_payout_history_note
                )
                policytaxyear.save()
                if policytaxyear.calculated_result != old_result:
                    # Tilføj note på policen om at mandtal har ændret resultatet
                    note_text = (
                        f"Personens antal skattedage i {self.year} er blevet opdateret;"
                        f" denne police er blevet påvirket af ændringen, og beregningen kan afvige fra en evt. oprettet slutopgørelse."
                    )
                    Note.objects.create(
                        person_tax_year=self,
                        policy_tax_year=policytaxyear,
                        author=get_admin_user(),
                        content=note_text,
                    )

    @property
    def slutlignet(self):
        return not self.policytaxyear_set.filter(slutlignet=False, active=True).exists()

    @property
    def efterbehandling(self):
        return self.policytaxyear_set.filter(efterbehandling=True).exists()

    @property
    def latest_processing_date(self):
        return self.policytaxyear_set.filter(
            next_processing_date__gte=timezone.now()
        ).aggregate(Max("next_processing_date"))["next_processing_date__max"]

    @property
    def active_policies_qs(self):
        return self.policytaxyear_set.filter(active=True)

    def __str__(self):
        return f"{self.__class__.__name__}(cpr={self.person.cpr}, year={self.tax_year.year})"

    history = HistoricalRecords()

    class Meta:
        ordering = ["-tax_year__year", "person__name"]
        unique_together = ["tax_year", "person"]
        permissions = [
            ("list_persontaxyear", "User is allow to use persontaxyear lists."),
        ]


class PersonTaxYearCensus(HistoryMixin, models.Model):
    class Meta:
        ordering = ["person_tax_year"]

    person_tax_year = models.ForeignKey(
        PersonTaxYear, null=False, on_delete=models.CASCADE
    )

    imported_kas_mandtal = models.UUIDField(null=False)

    number_of_days = models.IntegerField(verbose_name="Antal dage", null=True)

    fully_tax_liable = models.BooleanField(
        verbose_name="Fuldt skattepligtig", default=True
    )


class PolicyTaxYear(HistoryMixin, models.Model):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.__original_year_adjusted_amount = self.year_adjusted_amount

    history = HistoricalRecords()
    objects = PolicyTaxYearManager()

    class Meta:
        unique_together = ["person_tax_year", "pension_company", "policy_number"]
        ordering = ["person_tax_year"]

    person_tax_year = models.ForeignKey(
        PersonTaxYear,
        on_delete=models.PROTECT,
        null=False,
        blank=True,
    )

    pension_company = models.ForeignKey(
        PensionCompany,
        on_delete=models.PROTECT,
        null=False,
        blank=True,
        verbose_name=_("Pensionsselskab"),
    )

    policy_number = models.CharField(
        max_length=40,
        blank=False,
        verbose_name=_("Policenummer"),
    )

    prefilled_amount = models.BigIntegerField(
        verbose_name=_("Beløb rapporteret fra pensionsselskab"),
        blank=True,
        null=True
        # Ikke justeret for dage i skatteår
    )

    self_reported_amount = models.BigIntegerField(
        verbose_name=_("Selvangivet beløb"),
        blank=True,
        null=True
        # Justeret for dage i skatteår
    )

    ACTIVE_AMOUNT_PREFILLED = 1
    ACTIVE_AMOUNT_SELF_REPORTED = 3

    active_amount_options = (
        (ACTIVE_AMOUNT_PREFILLED, prefilled_amount.verbose_name),
        (ACTIVE_AMOUNT_SELF_REPORTED, self_reported_amount.verbose_name),
    )

    active_amount = models.SmallIntegerField(
        verbose_name=_("Beløb brugt til beregning"),
        choices=active_amount_options,
        default=ACTIVE_AMOUNT_PREFILLED,
    )

    prefilled_amount_edited = models.BigIntegerField(
        verbose_name=_("Justeret R75 beløb"),
        blank=True,
        null=True
        # Ikke justeret for dage i skatteår
    )
    assessed_amount = models.BigIntegerField(
        verbose_name=_("Ansat beløb"),
        blank=True,
        null=True
        # Justeret for dage i skatteår
    )
    base_calculation_amount = models.BigIntegerField(
        verbose_name=_("Nuværende beløb til grund for skatteberegningen"),
        blank=True,
        null=True,
        # Beløb benyttet til beregningen af kapitalafkastskatten
    )

    year_adjusted_amount = models.BigIntegerField(
        verbose_name=_("Beløb justeret for dage i skatteår"),
        default=0
        # Justeret for dage i skatteår (ved at gange faktor på efter behov)
    )
    __original_year_adjusted_amount = None

    CALCULATION_MODEL_DEFAULT = 1
    CALCULATION_MODEL_ALTERNATIVE = 2
    # TODO: Find the right terms here
    calculations_model_options = (
        (CALCULATION_MODEL_DEFAULT, _("Standard")),
        (CALCULATION_MODEL_ALTERNATIVE, _("Alternativ")),
    )
    calculation_model = models.SmallIntegerField(
        verbose_name=_("Beregningsmodel"),
        choices=calculations_model_options,
        default=CALCULATION_MODEL_DEFAULT,
    )

    preliminary_paid_amount = models.BigIntegerField(
        verbose_name=_("Foreløbigt betalt kapitalafkast"),
        blank=True,
        null=True,
        validators=(MinValueValidator(limit_value=0),),
        default=0,
    )

    from_pension = models.BooleanField(
        default=False,
        verbose_name=_("Er kapitalafkastskatten hævet fra pensionsordning"),
    )

    foreign_paid_amount_self_reported = models.BigIntegerField(
        verbose_name=_("Selvangivet beløb for betalt kapitalafkastskat i udlandet"),
        blank=True,
        default=0,
        validators=(MinValueValidator(limit_value=0),),
    )

    foreign_paid_amount_actual = models.BigIntegerField(
        verbose_name=_("Faktisk betalt kapitalafkastskat i udlandet"),
        blank=True,
        default=0,
        validators=(MinValueValidator(limit_value=0),),
    )

    calculated_full_tax = models.BigIntegerField(
        verbose_name=_("Beregnet skat uden fradrag"),
        blank=True,
        default=0,
    )

    calculated_result = models.BigIntegerField(
        verbose_name=_("Beregnet resultat"),
        blank=True,
        default=0,
    )

    available_negative_return = models.BigIntegerField(
        verbose_name=_(
            "Tilgængeligt fradrag fra andre år (beregnet ud fra andre data)"
        ),
        blank=True,
        null=True,
        default=None,
        editable=False,
    )

    modified_by = models.CharField(
        max_length=255, verbose_name=_("Modificeret af"), default="unknown"
    )

    locked = models.BooleanField(
        verbose_name=_("Låst"), help_text=_("Låst"), default=False
    )

    active = models.BooleanField(
        verbose_name=_("Aktiv"),
        default=True,
    )

    slutlignet = models.BooleanField(verbose_name=_("Slutlignet"), default=False)
    efterbehandling = models.BooleanField(
        verbose_name=_("Kræver efterbehandling"), default=False
    )

    next_processing_date = models.DateField(
        null=True, blank=True, verbose_name=_("Næste behandlingsdato")
    )

    # Overstyring af pensionsselskabs-betaling; borgeren skal betale selvom der foreligger aftale med pensionsselskab
    citizen_pay_override = models.BooleanField(
        default=False,
        verbose_name=_(
            "Borgeren betaler selvom der foreligger aftale med pensionsselskab"
        ),
    )

    # Overstyring af pensionsselskabs-betaling; selskabet betaler selvom der ikke foreligger aftale med pensionsselskab
    # citizen_pay_override tager præcedens over company_pay_override; hvis citizen_pay_override er True, betaler borgeren
    # uanset hvad company_pay_override er sat til
    company_pay_override = models.BooleanField(
        default=False,
        verbose_name=_(
            "Pensionsselskabet betaler selvom der ikke foreligger aftale med pensionsselskab"
        ),
    )

    updated_by = models.CharField(max_length=150, null=True)

    agterskrivelse = models.ForeignKey(
        "Agterskrivelse",
        null=True,
        on_delete=models.SET_NULL,
    )

    indifference_limited = models.BooleanField(default=False)

    @classmethod
    def perform_calculation(
        cls,
        initial_amount: int,  # The full base amount for the whole tax year
        days_in_year: int = 365,  # Days in the year of the calculation
        taxable_days_in_year: int = 365,  # Number of days the person is paying tax in Greenland
        available_deduction_data: dict = None,  # Dict of years to available deduction amounts
        foreign_paid_amount: int = 0,  # Amount already paid in taxes in foreign country
        preliminary_payment: int = 0,  # Amount already paid in taxes domestically
        adjust_for_days_in_year: bool = True,  # Perform adjustment for taxable days in year (false if self-reported)
        pension_company_pays: bool = False,  # Sets tax_to_pay to zero if pension company pays
    ) -> dict:
        if days_in_year not in (365, 366):
            raise ValueError("Days in year must be either 365 or 366")

        if taxable_days_in_year < 0:
            raise ValueError("Taxable days must be zero or higher")

        if taxable_days_in_year > days_in_year:
            raise ValueError("More taxable days than days in year")

        if initial_amount is None:
            raise ValueError("Initial amount is not set")

        if available_deduction_data is None:
            available_deduction_data = {}

        for year, amount in available_deduction_data.items():
            if amount < 0:
                raise ValueError(
                    "Negative return should be specified using a positive number"
                )

        if foreign_paid_amount < 0:
            raise ValueError("Foreign paid amount must be zero or higher")

        # Calculate taxable days adjust factor
        if adjust_for_days_in_year:
            tax_days_adjust_factor = taxable_days_in_year / days_in_year
        else:
            tax_days_adjust_factor = 1

        # Make sure initial amount is an integer
        initial_amount = int(initial_amount)

        # Adjust for taxable days. Round down because we only operate in integer amounts of money
        year_adjusted_amount = int(initial_amount * tax_days_adjust_factor)

        taxable_amount = max(0, year_adjusted_amount)
        used_negative_return = 0
        desired_deduction_data = {}
        # Given the available_deduction_data dict, calculate how much deduction we want
        if taxable_amount > 0:
            for year, amount in sorted(
                available_deduction_data.items(), key=lambda kvp: kvp[0]
            ):
                if amount > 0:
                    used_amount = min(amount, taxable_amount)
                    taxable_amount -= used_amount
                    used_negative_return += used_amount
                    desired_deduction_data[year] = used_amount
                    if taxable_amount == 0:
                        break

            # Taxable amount
            assert taxable_amount == year_adjusted_amount - used_negative_return

        # The amount of negative return that can actually be used
        available_negative_return = sum(available_deduction_data.values())

        # Calculate the tax
        full_tax = math.floor(taxable_amount * settings.KAS_TAX_RATE)

        tax_with_deductions = max(
            0, full_tax - max(0, foreign_paid_amount) - max(0, preliminary_payment)
        )
        tax_to_pay = tax_with_deductions

        if (
            pension_company_pays
            or abs(tax_to_pay) < settings.TRANSACTION_INDIFFERENCE_LIMIT
        ):
            tax_to_pay = 0

        return {
            "initial_amount": initial_amount,
            "days_in_year": days_in_year,
            "taxable_days_in_year": taxable_days_in_year,
            "foreign_paid_amount": foreign_paid_amount,
            "tax_days_adjust_factor": tax_days_adjust_factor,
            "year_adjusted_amount": year_adjusted_amount,
            "available_negative_return": available_negative_return,
            "used_negative_return": used_negative_return,
            "taxable_amount": taxable_amount,
            "full_tax": full_tax,
            "tax_with_deductions": tax_with_deductions,
            "desired_deduction_data": desired_deduction_data,
            "adjust_for_days_in_year": adjust_for_days_in_year,
            "tax_to_pay": tax_to_pay,
        }

    @property
    def full_tax(self):
        """
        Returns the full tax
        """
        only_adjusted_amounts = True
        calculation_result = self.perform_calculation(
            initial_amount=int(self.get_base_calculation_amount(only_adjusted_amounts)),
            taxable_days_in_year=int(self.person_tax_year.number_of_days or 0),
            days_in_year=int(self.person_tax_year.tax_year.days_in_year or 0),
            available_deduction_data=self.calculate_available_yearly_deduction(),
            adjust_for_days_in_year=(not only_adjusted_amounts)
            and self.should_adjust_for_tax_days,
        )
        return calculation_result["full_tax"]

    @property
    def initial_amount(self):
        if self.active_amount == self.ACTIVE_AMOUNT_PREFILLED:
            return self.prefilled_amount
        if self.active_amount == self.ACTIVE_AMOUNT_SELF_REPORTED:
            return self.self_reported_amount

    @property
    def person(self):
        return self.person_tax_year.person

    @property
    def tax_year(self):
        return self.person_tax_year.tax_year

    @property
    def year(self):
        return self.tax_year.year

    @property
    def cpr(self):
        return self.person.cpr

    @property
    def same_policy_qs(self):
        return PolicyTaxYear.objects.filter(
            person_tax_year__person__cpr=self.cpr,
            pension_company=self.pension_company,
            policy_number=self.policy_number,
        )

    @property
    def same_policy_qs_sorted_by_year(self):
        return self.same_policy_qs.order_by("-person_tax_year__tax_year__year")

    @property
    def latest_policy(self):
        policies = list(self.same_policy_qs_sorted_by_year)
        # If the filtering for same policies returns an empty list, return original policytaxyear
        if not policies:
            return self
        return policies[0]

    @property
    def policy_at_final_settlement(self):
        """
        If policy is involved in a final settlement, returns the version of policy
        that was valid, when the final settlement was generated
        """
        final_settlements = FinalSettlement.objects.filter(
            person_tax_year__person__id=self.person_tax_year.person.id,
            person_tax_year__tax_year__year=self.person_tax_year.tax_year.year,
        )
        if not final_settlements:
            return None
        final_settlement_creation_date = final_settlements.order_by("-created_at")[
            0
        ].created_at
        policy_qs = self.history.filter(
            history_date__lte=final_settlement_creation_date
        )
        if not policy_qs:
            return None
        return policy_qs.order_by("-history_date")[0]

    @property
    def policy_at_final_settlement(self):
        """
        If policy is involved in a final settlement, returns the version of policy
        that was valid, when the final settlement was generated
        """
        final_settlement_creation_date = FinalSettlement.objects.filter(
            person_tax_year__person__id=self.person_tax_year.person.id,
            person_tax_year__tax_year__year=self.person_tax_year.tax_year.year,
        )
        if not final_settlement_creation_date:
            return None
        final_settlement_creation_date = final_settlement_creation_date.order_by(
            "-created_at"
        )[0].created_at
        policy_qs = self.history.filter(
            history_date__lte=final_settlement_creation_date
        )
        if not policy_qs:
            return None
        return policy_qs.order_by("-history_date")[0]
        

    @property
    def reported_difference(self):
        if self.self_reported_amount is None or self.prefilled_adjusted_amount is None:
            return None
        return self.self_reported_amount - self.prefilled_adjusted_amount

    @property
    def reported_difference_pct(self):
        diff = self.reported_difference
        prefilled_adjusted_amount = self.prefilled_adjusted_amount
        if (
            diff is None
            or prefilled_adjusted_amount is None
            or prefilled_adjusted_amount == 0
        ):
            return None
        return round(diff / prefilled_adjusted_amount * 100, 2)

    @property
    def used_from(self):
        return self.payouts_used.order_by("used_from__person_tax_year__tax_year__year")

    def previous_years_qs(self, years=10):
        # Finds posts for the last ten years with the same
        # cpr, pension company and policy number
        return self.same_policy_qs.filter(
            person_tax_year__tax_year__year__lt=self.year,
            person_tax_year__tax_year__year__gte=self.year - years,
        )

    def subsequent_years_qs(self):
        # Finds posts for following years with the same
        # cpr, pension company and policy number
        return self.same_policy_qs.filter(person_tax_year__tax_year__year__gt=self.year)

    def get_calculation(self):
        only_adjusted_amounts = True
        return PolicyTaxYear.perform_calculation(
            initial_amount=self.get_base_calculation_amount(only_adjusted_amounts),
            days_in_year=self.tax_year.days_in_year,
            taxable_days_in_year=self.person_tax_year.number_of_days,
            available_deduction_data=self.calculate_available_yearly_deduction(),
            foreign_paid_amount=self.foreign_paid_amount_actual,
            preliminary_payment=self.preliminary_paid_amount or 0,
            adjust_for_days_in_year=(not only_adjusted_amounts)
            and self.should_adjust_for_tax_days,
            pension_company_pays=self.pension_company_pays,
        )

    def calculate_available_yearly_deduction(self):
        available = {}
        qs = (
            self.previous_years_qs()
            .filter(year_adjusted_amount__lt=0, active=True)
            .order_by("person_tax_year__tax_year__year")
        )
        # Loop over prior years, using deductible amounts from them until either we have used it all, or nothing more is needed
        for policy in qs.iterator():
            result = policy.payouts_using.exclude(used_for=self.id).aggregate(
                Sum("transferred_negative_payout")
            )
            used = result["transferred_negative_payout__sum"] or 0
            available[policy.year] = (
                -policy.year_adjusted_amount
            ) - used  # Positive value

        if available:
            if min(available.values()) < 0:
                available = self.adjust_deduction_data_for_negative_remaining_values()

        return available

    def modify_deduction_data_for_protected_cells(
        self, original_desired_deduction_data
    ):
        """
        Modifies a desired_deduction_data dictionary such that protected cells will not
        be updated (if possible)

        A cell is protected when
        PreviousYearNegativePayout.protected_against_recalculations = True
        """
        modified_desired_deduction_data = {}

        # Find protected payouts
        protected_payouts_used = self.payouts_used.filter(
            protected_against_recalculations=True
        ).order_by("-used_from__person_tax_year__tax_year__year")

        # If there are none - There is no need to do anything
        if not protected_payouts_used:
            return original_desired_deduction_data

        # Find the transferred negative payout in each year
        protected_year_dict = {
            q.used_from.year: q.transferred_negative_payout
            for q in protected_payouts_used
        }

        available_deduction_data = self.calculate_available_yearly_deduction()

        protected_amount = sum(protected_year_dict.values())
        total_amount = sum(original_desired_deduction_data.values())
        amount_to_put_elsewhere = total_amount - protected_amount

        if amount_to_put_elsewhere == 0:
            return original_desired_deduction_data

        elif amount_to_put_elsewhere > 0:
            # Create a new deduction data dictionary - keeping protected values as they are
            for year in sorted(available_deduction_data):
                if year not in protected_year_dict:
                    amount_to_put_in_this_year = min(
                        amount_to_put_elsewhere,
                        available_deduction_data[year],
                    )

                    if amount_to_put_in_this_year != 0:
                        modified_desired_deduction_data[
                            year
                        ] = amount_to_put_in_this_year
                        amount_to_put_elsewhere -= amount_to_put_in_this_year

                else:
                    modified_desired_deduction_data[year] = protected_year_dict[year]
        else:
            # Adjust protected cells down until we reach the desired amount
            amount_to_deduct = -amount_to_put_elsewhere

            for protected_payout_used in protected_payouts_used:
                year = protected_payout_used.used_from.year
                amount_to_deduct_from_this_year = min(
                    amount_to_deduct,
                    protected_payout_used.transferred_negative_payout,
                )
                protected_payout_used.transferred_negative_payout -= (
                    amount_to_deduct_from_this_year
                )
                protected_payout_used._change_reason = _(
                    "automatisk rettelse for at undgå at det totale anvendte beløb er over %d"
                    % total_amount
                )

                protected_payout_used.save()
                amount_to_deduct -= amount_to_deduct_from_this_year

                modified_desired_deduction_data[
                    year
                ] = protected_payout_used.transferred_negative_payout

                if amount_to_deduct == 0:
                    break

        return modified_desired_deduction_data

    def recalculate(
        self,
        negative_payout_history_note=_("Genberegning"),
        save_without_negative_payout_history=False,
    ):
        payouts_used_qs = self.payouts_used.exclude(
            transferred_negative_payout=0
        ).exclude(protected_against_recalculations=True)

        # Set payouts to zero rather than deleting. If we delete we lose history.
        for payout_used in payouts_used_qs:
            payout_used.transferred_negative_payout = 0
            payout_used._change_reason = negative_payout_history_note
            payout_used.save()

        result = self.get_calculation()

        result[
            "desired_deduction_data"
        ] = self.modify_deduction_data_for_protected_cells(
            result["desired_deduction_data"]
        )

        self.indifference_limited = (
            result["tax_with_deductions"] < settings.TRANSACTION_INDIFFERENCE_LIMIT
        )
        for payout_used in payouts_used_qs:
            # If this object will be created later on in the code:
            if payout_used.used_from.year in result["desired_deduction_data"].keys():
                # Remove the history entry to avoid duplicate history entries
                latest_history_entry = payout_used.history.order_by("-history_date")[0]
                latest_history_entry.delete()

        other_policies = {
            policy.year: policy
            for policy in self.previous_years_qs().filter(active=True)
        }
        for year, amount in result["desired_deduction_data"].items():
            other_policies[year].use_amount(
                amount,
                self,
                negative_payout_history_note=negative_payout_history_note,
                save_without_negative_payout_history=save_without_negative_payout_history,
            )

        old_year_adjusted_amount = self.year_adjusted_amount
        self.year_adjusted_amount = result["year_adjusted_amount"]
        self.calculated_full_tax = result["full_tax"]
        self.available_negative_return = result["available_negative_return"]
        self.calculated_result = result["tax_with_deductions"]

        if (
            old_year_adjusted_amount <= 0 or self.year_adjusted_amount <= 0
        ) and old_year_adjusted_amount != self.year_adjusted_amount:
            # When tax base is changed from or to negative, mark subsequent policies,
            # as the available deductible amount will have changed
            # This text has not been translated by request of the customer
            note_text = f"Policen for {self.year} er blevet opdateret; denne police kan være påvirket af ændringen."

            for other_policy_tax_year in self.subsequent_years_qs():
                other_policy_tax_year.efterbehandling = True
                other_policy_tax_year.save()

                Note.objects.create(
                    person_tax_year=other_policy_tax_year.person_tax_year,
                    policy_tax_year=other_policy_tax_year,
                    author=get_admin_user(),
                    content=note_text,
                )

    def adjust_deduction_data_for_negative_remaining_values(self):
        """
        Checks and adjusts negative payout table to see if a value in it is too high
        compared to the available negative payout. And adjusts if necessary.
        """

        remaining_deduction_data = {
            year: inner_dict["remaining"]
            for year, inner_dict in self.latest_policy.previous_year_deduction_table_data.items()
        }

        years_with_below_zero_amount = [
            y
            for y in remaining_deduction_data.keys()
            if remaining_deduction_data[y] < 0
        ]

        policies_to_be_recalculated = []

        for year in years_with_below_zero_amount:
            future_policies = self.same_policy_qs_sorted_by_year.filter(
                person_tax_year__tax_year__year__gt=year
            )
            total_amount_to_adjust = remaining_deduction_data[year] * -1

            negative_payout_objects = []
            for policy in future_policies:
                try:
                    negative_payout_objects.append(
                        policy.payouts_used.get(
                            used_from__person_tax_year__tax_year__year=year,
                            used_for__person_tax_year__tax_year__year=policy.person_tax_year.tax_year.year,
                        )
                    )
                except policy.payouts_used.model.DoesNotExist:
                    pass

            # Separate into protected and non-protected objects
            protected_negative_payout_objects = [
                n for n in negative_payout_objects if n.protected_against_recalculations
            ]

            non_protected_negative_payout_objects = [
                n
                for n in negative_payout_objects
                if not n.protected_against_recalculations
            ]

            # Put them together again - so we loop over non-protected objects first
            negative_payout_objects = (
                non_protected_negative_payout_objects
                + protected_negative_payout_objects
            )

            for negative_payout_object in negative_payout_objects:
                policy = negative_payout_object.used_for

                amount_to_adjust_with = min(
                    negative_payout_object.transferred_negative_payout,
                    total_amount_to_adjust,
                )

                negative_payout_object.transferred_negative_payout -= (
                    amount_to_adjust_with
                )
                negative_payout_object._change_reason = _(
                    "automatisk rettelse for at undgå at det totale resterende beløb falder under 0"
                )
                negative_payout_object.save()

                if policy not in policies_to_be_recalculated:
                    policies_to_be_recalculated.extend([policy])

                total_amount_to_adjust -= amount_to_adjust_with

                if total_amount_to_adjust == 0:
                    break

        for policy in policies_to_be_recalculated:
            policy.recalculate()

        return self.calculate_available_yearly_deduction()

    def save(self, *args, **kwargs):
        super(PolicyTaxYear, self).save(*args, **kwargs)

        # If year_adjusted_amount was changed:
        if self.year_adjusted_amount != self.__original_year_adjusted_amount:
            # Make sure that negative values can never appear in the negative payout table
            # This can happen if (for example) the self-reported amount is adjusted to a lower value
            self.adjust_deduction_data_for_negative_remaining_values()

    def sum_of_used_amount(self):
        # Deliver the amount of this years loss used in other years deduction
        result = self.payouts_using.aggregate(Sum("transferred_negative_payout"))

        value = result["transferred_negative_payout__sum"]
        if value is None:
            return 0

        return value

    # Make a registration that we use some ot self's loss as deductoin on 'deducting_policy_tax_year'
    def use_amount(
        self,
        use_up_to_amount,
        deducting_policy_tax_year,
        negative_payout_history_note="",
        save_without_negative_payout_history=False,
    ):
        # Create a relation of usage of this years loss as deduction in other years
        if self.year_adjusted_amount >= 0:
            return 0

        if self.sum_of_used_amount() >= -self.year_adjusted_amount:
            return 0

        available_to_be_used_amount = (
            -self.year_adjusted_amount
        ) - self.sum_of_used_amount()
        to_be_used_amount = min(available_to_be_used_amount, use_up_to_amount)

        item, created = PreviousYearNegativePayout.objects.get_or_create(
            used_from=self, used_for=deducting_policy_tax_year
        )

        if created:
            item.history.last().delete()

        if item.protected_against_recalculations is False:
            item.transferred_negative_payout += to_be_used_amount
            item._change_reason = negative_payout_history_note
            item.save()

            if save_without_negative_payout_history:
                latest_history_entry = item.history.order_by("-history_date")[0]
                latest_history_entry.delete()

        return to_be_used_amount

    @property
    def available_deduction_from_previous_years(self):
        if self.available_negative_return is None:
            self.available_negative_return = sum(
                self.calculate_available_yearly_deduction().values()
            )
        return self.available_negative_return

    @property
    def applied_deduction_from_previous_years(self):
        # Return the amount of deductions used by this policy (losses from other years used as deductions in this year)
        result = self.payouts_used.aggregate(Sum("transferred_negative_payout"))
        return result["transferred_negative_payout__sum"] or 0

    @property
    def previous_year_deduction_table_data(self):
        years = []
        policy_pks = []
        available_by_year = {}
        used_by_year = {}
        for_year_total = {}
        for_year_max = {}

        for x in self.same_policy_qs.filter(
            person_tax_year__tax_year__year__lte=self.year, active=True
        ).order_by("person_tax_year__tax_year__year"):
            years.append(x.year)
            policy_pks.append(x.pk)
            available_by_year[x.year] = min(x.year_adjusted_amount, 0) * -1
            used_by_year[x.year] = 0
            for_year_total[x.year] = 0
            base_calculation_amount = x.get_base_calculation_amount()

            if base_calculation_amount is None:
                for_year_max[x.year] = 0
            else:
                for_year_max[x.year] = max(0, base_calculation_amount)

        used_matrix = {}

        for x in PreviousYearNegativePayout.objects.filter(
            used_from__in=policy_pks,
            used_for__in=policy_pks,
            used_for__person_tax_year__tax_year__year__lte=self.year,
        ):
            if x.from_year not in used_matrix:
                used_matrix[x.from_year] = {}

            # Store used amount in matrix
            used_matrix[x.from_year][x.for_year] = x.transferred_negative_payout
            # Adjust spent amount for the from year
            used_by_year[x.from_year] = (
                used_by_year[x.from_year] + x.transferred_negative_payout
            )
            # Adjust used amount for the for year
            for_year_total[x.for_year] = (
                for_year_total[x.for_year] + x.transferred_negative_payout
            )

        result = {}

        # create a year x year table
        for x in years:
            used_in = {}
            used_max = {}
            remaining = available_by_year[x] - used_by_year[x]

            for y in years:
                if x >= y:
                    used_in[y] = "-"
                else:
                    used_in[y] = used_matrix.get(x, {}).get(y, 0)
                    used_max[y] = min(
                        remaining + used_in[y],
                        for_year_max[y] - for_year_total[y] + used_in[y],
                    )

            result[x] = {
                "available": available_by_year[x],
                "used_by_year": used_in,
                "used_max_by_year": used_max,
                "remaining": remaining,
                "used_total": for_year_total[x],
                "used_max": for_year_max[x],
            }

        return result

    @property
    def years_with_protected_negative_payout(self):
        """
        Find out which (from/for) year combinations have protected cells in the negative
        payout table
        """

        policies = self.same_policy_qs

        objects_with_protected_cells = PreviousYearNegativePayout.objects.filter(
            used_from__in=policies,
            used_for__in=policies,
            protected_against_recalculations=True,
        )

        output = [
            (entry.used_from.year, entry.used_for.year)
            for entry in objects_with_protected_cells
        ]

        return list(set(output))

    @property
    def years_with_negative_payout_history(self):
        """
        Find out which (from/for) year combinations have history in the negative
        payout table
        """
        policies = self.same_policy_qs

        objects_with_history = PreviousYearNegativePayout.history.filter(
            used_from__in=policies, used_for__in=policies
        )

        output = [
            (entry.used_from.year, entry.used_for.year)
            for entry in objects_with_history
        ]

        return list(set(output))

    @property
    def sum_of_deducted_amount(self):
        # Return the amount of this years deduction (losses used as deductions in other years)
        result = self.payouts_using.aggregate(Sum("transferred_negative_payout"))
        return result["transferred_negative_payout__sum"] or 0

    # How much deduction is still available for use on this policy
    # Returns a positive number
    @property
    def remaining_negative_amount(self):
        return max(0, (-self.year_adjusted_amount) - self.sum_of_deducted_amount)

    def recalculate_from_r75(self):
        r75qs = ImportedR75PrivatePension.objects.filter(
            cpr=self.cpr,
            tax_year=self.year,
            res=self.pension_company.res,
            ktd=self.policy_number,
        )
        self.prefilled_amount = sum(
            [int(r["renteindtaegt"]) for r in r75qs.values("renteindtaegt")]
        )
        self.save()

    def get_base_calculation_amount(self, only_adjusted=True):
        """
        Return base_calculation_amount based on estimated_mount, self_reported_amount,
        prefilled_amount_edited and prefilled_amount.
        :param only_adjusted: Whether to use prefilled_adjusted_amount (adjusted) or prefilled_amount (not adjusted)
        :return: base_calculation_amount or None
        """
        amounts_list = [
            self.assessed_amount,
            self.self_reported_amount,
        ]
        if only_adjusted:
            amounts_list += [
                self.prefilled_adjusted_amount,
                self.base_calculation_amount,
            ]
        else:
            amounts_list += [
                self.prefilled_amount_edited,
                self.prefilled_amount,
            ]
        amounts_list.append(0)
        return next((item for item in amounts_list if item is not None), None)

    @property
    def should_adjust_for_tax_days(self):
        # Do not adjust:
        # * self.assessed_amount
        # * self_reported_amount
        # Do adjust:
        # * prefilled_amount_edited
        # * prefilled_amount
        return self.assessed_amount is None and self.self_reported_amount is None

    @property
    def prefilled_adjusted_amount(self):
        # The prefilled amount, but adjusted for tax days
        amount = self.prefilled_amount_edited
        if amount is None:
            amount = self.prefilled_amount
        if amount is None:
            return None
        factor = (
            self.person_tax_year.number_of_days
            / self.person_tax_year.tax_year.days_in_year
        )
        return int(amount * factor)

    @property
    def pension_company_pays(self):
        return (
            self.pension_company.agreement_present or self.company_pay_override
        ) and not self.citizen_pay_override

    def __str__(self):
        return (
            f"{self.__class__.__name__}(policy_number={self.policy_number}, cpr={self.person.cpr}, "
            f"year={self.tax_year.year}), prefilled_amount={self.prefilled_amount}, "
            f"self_reported_amount={self.self_reported_amount}, "
            f"calculations_model_options={self.calculations_model_options}, active_amount={self.active_amount}, "
            f"year_adjusted_amount={self.year_adjusted_amount}, calculation_model={self.calculation_model}, "
            f"preliminary_paid_amount={self.preliminary_paid_amount}, from_pension={self.from_pension}, "
            f"foreign_paid_amount_self_reported={self.foreign_paid_amount_self_reported}, "
            f"foreign_paid_amount_actual={self.foreign_paid_amount_actual}, "
            f"applied_deduction_from_previous_years={self.applied_deduction_from_previous_years}"
        )


class PreviousYearNegativePayout(models.Model):
    class Meta:
        ordering = ["used_from"]

    history = HistoricalRecords(history_change_reason_field=models.TextField(null=True))

    used_from = models.ForeignKey(
        PolicyTaxYear, related_name="payouts_using", null=True, on_delete=models.PROTECT
    )

    used_for = models.ForeignKey(
        PolicyTaxYear, related_name="payouts_used", null=True, on_delete=models.PROTECT
    )

    transferred_negative_payout = models.BigIntegerField(
        verbose_name=_("Overført negativt afkast"),
        blank=True,
        default=0,
    )

    protected_against_recalculations = models.BooleanField(
        default=False, verbose_name=_("Beskyt mod genberegning")
    )

    @property
    def from_year(self):
        return self.used_from.year

    @property
    def for_year(self):
        return self.used_for.year

    def __str__(self):
        return f"used from :{self.used_from} used for :{self.used_for} payout :{self.transferred_negative_payout}"


def policydocument_file_path(instance, filename):
    return f"policydocuments/{instance.person_tax_year.year}/{uuid.uuid4()}"


class PolicyDocument(models.Model):
    class Meta:
        ordering = ["person_tax_year", "uploaded_at"]

    person_tax_year = models.ForeignKey(
        PersonTaxYear, null=False, db_index=True, on_delete=models.PROTECT
    )
    uploaded_by = models.ForeignKey(
        get_user_model(), null=True, on_delete=models.PROTECT
    )
    uploaded_at = models.DateTimeField(auto_now_add=True)
    policy_tax_year = models.ForeignKey(
        PolicyTaxYear,
        on_delete=models.PROTECT,
        null=True,
        related_name="policy_documents",
    )

    name = models.CharField(max_length=255, verbose_name=_("Navn"), blank=False)

    description = models.TextField(
        verbose_name=_("Beskrivelse"),
        blank=True,
    )

    file = models.FileField(
        verbose_name=_("Fil"),
        blank=False,
        upload_to=policydocument_file_path,
    )


post_delete.connect(
    delete_file, sender=PolicyDocument, dispatch_uid="delete_policy_document"
)


def set_all_documents_and_notes_handled(
    sender, instance, created, raw, using, update_fields, **kwargs
):
    if created is True and instance.policy_tax_year is None:
        with atomic():
            person_tax_year = PersonTaxYear.objects.filter(
                pk=instance.person_tax_year_id
            ).select_for_update()[0]
            if person_tax_year.all_documents_and_notes_handled is True:
                person_tax_year.all_documents_and_notes_handled = False
                person_tax_year.save(update_fields=["all_documents_and_notes_handled"])


post_save.connect(
    set_all_documents_and_notes_handled,
    PolicyDocument,
    dispatch_uid="set_document_and_notes_handled",
)


class R75(models.Model):
    class Meta:
        ordering = ["person_tax_year"]

    person_tax_year = models.ForeignKey(
        PersonTaxYear,
        on_delete=models.PROTECT,
    )

    preprinted_net_return = models.BigIntegerField(
        verbose_name=_("Fortrykt nettoafkast"), default=0
    )


class PriorYear(models.Model):
    class Meta:
        ordering = ["person"]

    person = models.ForeignKey(Person, on_delete=models.PROTECT)

    tax_paid_in_prior_years = models.BigIntegerField(
        db_index=True,
        verbose_name=_("Skat betalt i tidligere år"),
        help_text=_("Skat betalt i tidligere år"),
    )


class Note(models.Model):
    class Meta:
        ordering = ["date"]

    history = HistoricalRecords()

    person_tax_year = models.ForeignKey(
        PersonTaxYear,
        null=False,
        on_delete=models.CASCADE,
        related_name="notes",
    )

    policy_tax_year = models.ForeignKey(
        PolicyTaxYear,
        null=True,
        on_delete=models.SET_NULL,
        related_name="notes",
    )

    date = models.DateTimeField(
        auto_now=True,
    )

    author = models.ForeignKey(
        get_user_model(),
        null=False,
        on_delete=models.PROTECT,
    )

    content = models.TextField(
        verbose_name=_("Tekst"),
    )


post_save.connect(
    set_all_documents_and_notes_handled,
    Note,
    dispatch_uid="set_document_and_notes_handled",
)


def add_skatteaar_to_queue(sender, instance, **kwargs):
    """
    for every change add an entry to the queue
    """
    # Queue.objects.create(item=instance, inserted_at=timezone.now())
    pass


post_save.connect(
    add_skatteaar_to_queue, TaxYear, dispatch_uid="Skatteaar.add_to_queue"
)


def pensioncompanysummaryfile_path(instance, filename):
    return f"pensioncompany_summary/{instance.tax_year.year}/{uuid.uuid4()}.csv"


class PensionCompanySummaryFile(models.Model):
    class Meta:
        ordering = ["company", "tax_year"]

    company = models.ForeignKey(
        PensionCompany,
        null=False,
        on_delete=models.CASCADE,
    )

    tax_year = models.ForeignKey(
        TaxYear,
        null=False,
        on_delete=models.CASCADE,
    )

    file = models.FileField(
        upload_to=pensioncompanysummaryfile_path,
        null=False,
    )

    creator = models.ForeignKey(
        get_user_model(),
        null=False,
        on_delete=models.CASCADE,
    )

    created = models.DateTimeField(
        auto_now_add=True,
        null=False,
    )

    @staticmethod
    def create(pension_company, tax_year, creator):
        # Generate a PensionCompanySummaryFile entry and populate a file for it
        qs = PolicyTaxYear.objects.filter(
            pension_company=pension_company, person_tax_year__tax_year=tax_year
        ).prefetch_related("person_tax_year", "person_tax_year__person")
        file_entry = PensionCompanySummaryFile.objects.create(
            company=pension_company, tax_year=tax_year, creator=creator
        )

        csvfile = StringIO()
        writer = csv.writer(
            csvfile, delimiter=";", quotechar='"', quoting=csv.QUOTE_MINIMAL
        )

        headers = [
            "Skatteår",
            "Reg.nr.",
            "Cpr.nr.",
            "Aftalenr.",
            "Afkast",
            "Modregnet negativt afkast tidl. år",
            "Beregningsgrundlag",
            "Forudbetaling",
            "Kapitalafkastskat",
            f"Afregnet af {pension_company.name}",
            "Bemærkninger",
        ]
        writer.writerow(headers)

        for policy_tax_year in qs.iterator():
            calculation = policy_tax_year.get_calculation()
            note = ""
            if calculation["year_adjusted_amount"] != calculation["initial_amount"]:
                note = "Afkast reduceret pga. af delvis skattepligt i året"
            pension_company_tax_to_pay = calculation["tax_with_deductions"]

            if (
                calculation["tax_with_deductions"]
                < settings.TRANSACTION_INDIFFERENCE_LIMIT
            ):
                pension_company_tax_to_pay = 0
                note += f"Kapitalafkastskat sat til 0kr., da den beregnede kapitalafkastskat {calculation['tax_with_deductions']}kr. er under minimumsgrænsen på {settings.TRANSACTION_INDIFFERENCE_LIMIT}kr."
            line = [
                policy_tax_year.tax_year.year,  # TaxYear (Integer, 4 digits, positive. XXXX eg. 2013)
                pension_company.res,  # Reg_se_nr (Integer, positive)
                policy_tax_year.cpr,  # Cpr: The CPR on the person
                policy_tax_year.policy_number,  # Police_no (Integer, positive)
                calculation[
                    "year_adjusted_amount"
                ],  # Tax base 1 per police (Return)(Integer)  # Årets justerede afkast
                calculation[
                    "used_negative_return"
                ],  # The previous year's negative return (Integer)
                calculation[
                    "taxable_amount"
                ],  # Tax base 2 (Tax base 1 minus the previous year's negative return)(Integer, 10 digits)
                policy_tax_year.preliminary_paid_amount
                or 0,  # Provisional tax paid (Integer, 10 digits, positive)
                pension_company_tax_to_pay,  # Tax to be paid by pension company (Integer)
                None,  # Actual settlement pension company (Empty column)
                note,
            ]
            writer.writerow(line)

        file_entry.file.save(
            f"{timezone.now().strftime('%Y-%m-%d %H.%M.%S UTC')}.csv",
            csvfile,
            save=True,
        )
        file_entry.save()
        csvfile.close()
        return file_entry


post_delete.connect(
    delete_file, sender=PensionCompanySummaryFile, dispatch_uid="delete_pension_file"
)


class PensionCompanySummaryFileDownload(models.Model):
    class Meta:
        ordering = ["downloaded_at"]

    downloaded_by = models.ForeignKey(
        get_user_model(),
        null=False,
        on_delete=models.CASCADE,
    )

    downloaded_at = models.DateTimeField(
        auto_now_add=True,
        null=False,
    )

    downloaded_to = models.GenericIPAddressField(
        null=True,
    )

    file = models.ForeignKey(
        PensionCompanySummaryFile,
        null=False,
        on_delete=models.CASCADE,
    )


def final_settlement_file_path(instance, filename):
    return f"settlements/{instance.person_tax_year.tax_year.year}/{uuid.uuid4()}.pdf"


class FinalSettlement(EboksDispatch):
    """
    Slutopgørelse
    """

    uuid = models.UUIDField(primary_key=True, default=uuid4)
    person_tax_year = models.ForeignKey(
        PersonTaxYear, null=False, db_index=True, on_delete=models.PROTECT
    )
    pdf = models.FileField(upload_to=final_settlement_file_path)
    invalid = models.BooleanField(
        default=False, verbose_name=_("Slutopgørelse er ikke gyldig")
    )

    lock = models.ForeignKey(Lock, on_delete=models.PROTECT, related_name="settlements")

    interest_on_remainder = models.DecimalField(
        default="0.0",
        max_digits=5,
        decimal_places=2,
        verbose_name=_(
            "Procentsats for hvor mange renter der skal lægges til for meget / for lidt opkrævet"
        ),
        blank=False,
        null=False,
    )

    extra_payment_for_previous_missing = models.IntegerField(
        default=0,
        validators=(MinValueValidator(limit_value=0),),
        verbose_name=_(
            "Ekstra beløb til betaling der dækker en delmængde af en tidligere ikke-betalt regning"
        ),
        blank=False,
        null=False,
    )

    PAYMENT_TEXT_BULK = 1
    PAYMENT_TEXT_DUE_ON_DATE = 2
    PAYMENT_TEXT_DUE = 3
    PAYMENT_TEXT_PREV_AMOUNT_DUE = 4
    PAYMENT_TEXT_REFUND = 5

    text_used_for_payment_choices = (
        (PAYMENT_TEXT_BULK, _("Standardtekst for automatisk slutopgørelse")),
        (PAYMENT_TEXT_DUE_ON_DATE, _("Beløbet forfalder på dato X")),
        (PAYMENT_TEXT_DUE, _("Beløbet er forfaldent")),
        (
            PAYMENT_TEXT_PREV_AMOUNT_DUE,
            _("Tidligere beløb er forfaldent, nyt beløb forfalder på dato X"),
        ),
        (PAYMENT_TEXT_REFUND, _("Tilbagebetaling")),
    )

    text_used_for_payment = models.IntegerField(
        verbose_name=_("Tekst om beløb til betaling"),
        choices=text_used_for_payment_choices,
        blank=False,
        null=False,
        default=PAYMENT_TEXT_BULK,
    )
    # pseudo final settlement original exists in eskat for 2018/2019
    # Being "pseudo" means that the FinalSettlement is not actually dispatched,
    # but only used for comparison to our own calculations, flagging the user if there are differences
    pseudo = models.BooleanField(default=False)
    # Final settlement ammount provided by the user when uploading the pdf.
    pseudo_amount = models.DecimalField(
        blank=False,
        max_digits=12,
        decimal_places=2,
        default=0,
    )

    indifference_limited = models.BooleanField(default=False)

    def dispatch_to_eboks(self, client: EboksClient, generator: EboksDispatchGenerator):
        return super().dispatch_to_eboks(
            client, generator, self.pdf, self.person_tax_year.person.cpr
        )

    def get_calculation_amounts(self):
        # Prepayment is zero or a negative number
        prepayment = (
            self.person_tax_year.transaction_set.filter(type="prepayment").aggregate(
                amount=Sum("amount")
            )["amount"]
            or 0
        )

        total_tax = sum(
            [
                policy.get_calculation()[
                    "tax_to_pay"
                ]  # Samme som tax_with_deductions, men med beløb under 100 kr nulstillet
                for policy in self.person_tax_year.active_policies_qs
                if not policy.pension_company_pays
            ]
        )

        previous_transactions_sum = sum(
            [
                transaction.amount
                for transaction in Transaction.objects.filter(
                    person_tax_year=self.person_tax_year,
                    status="transferred",
                    type="prisme10q",
                )
            ]
        )

        remainder = (
            total_tax - previous_transactions_sum - (-prepayment)
        )  # Prepayment is negative

        qs = self.get_other_statements().filter(invalid=False)
        if self.created_at:
            qs = qs.filter(created_at__lt=self.created_at)
        applicable_previous_statements_exist = qs.exists()
        interest_factor = 0.01 * float(self.interest_on_remainder)
        interest_amount_on_remainder = (
            int(interest_factor * remainder)
            if applicable_previous_statements_exist
            else 0
        )

        remainder_with_interest = remainder + interest_amount_on_remainder

        total_payment = (
            remainder_with_interest + self.extra_payment_for_previous_missing
        )
        # Enforcing indifference limit on transactions, where abs(amount) < 100kr.
        if abs(total_payment) < settings.TRANSACTION_INDIFFERENCE_LIMIT:
            self.indifference_limited = True
            self.save()
            total_payment = 0

        return {
            "prepayment": prepayment,
            "applicable_previous_statements_exist": applicable_previous_statements_exist,
            "total_tax": total_tax,  # Positive when paying tax
            "previous_transactions_sum": previous_transactions_sum,  # Positive for paid (or billed) tax
            "remainder": remainder,  # Difference; positive when paying tax, negative when refunding
            "interest_percent": self.interest_on_remainder,
            "interest_factor": interest_factor,
            "interest_amount_on_remainder": interest_amount_on_remainder,  # Interest; positive when paying tax, negative when refunding. None if no previous transactions
            "remainder_with_interest": remainder_with_interest,
            "extra_payment_for_previous_missing": self.extra_payment_for_previous_missing,  # Employee-specified amount; positive when paying tax
            "total_payment": total_payment,
        }

    def get_other_statements(self):
        qs = self.person_tax_year.finalsettlement_set
        if self.uuid is not None:
            qs = qs.exclude(uuid=self.uuid)
        return qs

    def get_payment_info(self):
        result = []

        for policy in self.person_tax_year.active_policies_qs:
            if policy.pension_company_pays:
                result.append(
                    {
                        "text": _(
                            "Afgift for police nr. {policenummer} ved {pensionsselskab} (betalt af pensionsselskab)"
                        ).format(
                            policenummer=policy.policy_number,
                            pensionsselskab=policy.pension_company.name,
                        ),
                        "amount": 0,
                        "source_object": policy,
                    }
                )
            else:
                amount = policy.get_calculation()[
                    "tax_with_deductions"
                ]  # skat der skal betales per police
                result.append(
                    {
                        "text": _(
                            "Afgift for police nr. {policenummer} ved {pensionsselskab}"
                        ).format(
                            policenummer=policy.policy_number,
                            pensionsselskab=policy.pension_company.name,
                        ),
                        "amount": amount,
                        "source_object": policy,
                    }
                )
        # modregn eksisterende transaktioner
        for transaction in Transaction.objects.filter(
            person_tax_year=self.person_tax_year,
            status="transferred",
        ):
            if transaction.type == "prepayment":
                result.append(
                    {
                        "text": _("Forudindbetaling"),
                        "amount": transaction.amount,  # prepayment are stored as negative so add the amount
                        "source_object": transaction,
                    }
                )
            elif transaction.type == "prisme10q":
                result.append(
                    {
                        "text": _(
                            "Justering fra årsopgørelse oprettet d. {oprettelsesdato}"
                        ).format(
                            oprettelsesdato=transaction.created_at,
                        ),
                        "amount": -transaction.amount,
                        "source_object": transaction,
                    }
                )

        remainder_calculation = self.get_calculation_amounts()

        # Beregn rente af udeståender hvis der er andre slutopgørelser
        if remainder_calculation["applicable_previous_statements_exist"]:
            result.append(
                {
                    "text": _("Rente af udeståender ({rente}% af {beløb})").format(
                        **{
                            "rente": self.interest_on_remainder,
                            "beløb": remainder_calculation["remainder"],
                        }
                    ),
                    "amount": remainder_calculation["interest_amount_on_remainder"],
                    "source_object": None,
                }
            )

        return result

    def get_transaction_summary(self):
        if self.pseudo:
            # TODO: Hvilken tekst skal stå ved transaktion for uploadet slutopgørelse?
            return _("Importeret:") + " " + str(self.pseudo_amount)

        payment_info = self.get_payment_info()

        summary = ""

        for x in payment_info:
            summary += x["text"] + ": " + str(x["amount"]) + "\n"

        summary += "\n"
        summary += _("I alt:") + " " + str(self.get_transaction_amount())

        return summary

    def get_transaction_amount(self):
        if self.pseudo:
            return self.pseudo_amount

        payment_info = self.get_payment_info()

        amount = 0

        for x in payment_info:
            amount += x["amount"]

        return amount

    def get_transaction(self):
        return Transaction.objects.filter(
            source_content_type=ContentType.objects.get_for_model(FinalSettlement),
            object_id=self.pk,
        ).first()

    @property
    def allow_dispatch(self):
        return super().allow_dispatch and not self.pseudo

    @cached_property
    def total_tax(self):
        return self.get_calculation_amounts().get("total_tax")

    @cached_property
    def previous_transactions_sum(self):
        return self.get_calculation_amounts().get("previous_transactions_sum")

    @property
    def remaining_transaction_sum(self):
        return self.total_tax - self.previous_transactions_sum

    class Meta:
        constraints = [
            # Ensure there can only by a single pseudo final settlement per person_tax_year
            UniqueConstraint(
                name="idx_pseudo_true",
                fields=["person_tax_year", "pseudo"],
                condition=Q(pseudo=True),
            )
        ]
        ordering = ["person_tax_year"]


def delete_pdf(sender, instance, using, **kwargs):
    if instance.pdf:
        # delete the pdf file
        instance.pdf.delete(save=False)


post_delete.connect(
    delete_pdf, sender=FinalSettlement, dispatch_uid="delete_final_settlement_pdf"
)


def agterskrivelse_file_path(instance, filename):
    return f"agterskrivelse/{instance.person_tax_year.tax_year.year}/{uuid.uuid4()}.pdf"


class Agterskrivelse(EboksDispatch):
    class Meta:
        ordering = ["person_tax_year"]

    uuid = models.UUIDField(primary_key=True, default=uuid4)
    person_tax_year = models.ForeignKey(PersonTaxYear, on_delete=models.CASCADE)
    pdf = models.FileField(upload_to=agterskrivelse_file_path)

    def dispatch_to_eboks(self, client: EboksClient, generator: EboksDispatchGenerator):
        return super().dispatch_to_eboks(
            client, generator, self.pdf, self.person_tax_year.person.cpr
        )


class AddressFromDafo(models.Model):
    cpr = models.TextField(unique=True, null=False)
    address = models.TextField(blank=True, null=True)
    postal_area = models.TextField(blank=True, null=True)
    name = models.TextField(blank=True, null=True)
    co = models.TextField(blank=True, null=True)
    full_address = models.TextField(blank=True, null=True)

    def is_dafo_address_better(self, person_item):
        if not self.name or not self.address or not self.postal_area:
            return False
        equal_name = self.name == person_item.name
        equal_adress = person_item.address_line_2 is not None and re.sub(
            "()_-,", "", self.address
        ) == re.sub("()_-,", "", person_item.address_line_2)
        equal_postal = (
            person_item.address_line_4 is not None
            and self.postal_area == person_item.address_line_4
        )
        return not (equal_name and equal_adress and equal_postal)

    def __str__(self):
        return "%s - %s" % (self.name, self.full_address)

    class Meta:
        ordering = ["cpr"]


@receiver(post_save, sender=FinalSettlement)
def cancel_batch_on_save(sender, instance, **kwargs):
    if (
        instance.invalid
        and instance.person_tax_year.tax_year.year_part == "genoptagelsesperiode"
    ):
        for transaction in Transaction.objects.filter(
            person_tax_year=instance.person_tax_year
        ).exclude(
            status="transferred",
        ):
            batch = transaction.prisme10q_batch
            if batch.status in (
                Prisme10QBatch.STATUS_CREATED,
                Prisme10QBatch.STATUS_DELIVERY_FAILED,
            ):
                batch.status = Prisme10QBatch.STATUS_CANCELLED
                batch.save(update_fields=["status"])


class RepresentationToken(models.Model):
    class Meta:
        ordering = ["created"]

    token = models.CharField(
        max_length=64,
        null=False,
        unique=True,
    )
    person = models.ForeignKey(Person, null=False, on_delete=models.CASCADE)
    user = models.ForeignKey(get_user_model(), null=False, on_delete=models.CASCADE)
    created = models.DateTimeField(auto_now_add=True)
    consumed = models.BooleanField(default=False)

    @staticmethod
    def generate_token():
        return "".join(
            [
                random.SystemRandom().choice(string.ascii_letters + string.digits)
                for _ in range(64)
            ]
        )
